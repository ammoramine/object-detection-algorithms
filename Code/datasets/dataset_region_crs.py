"""
    dataset object (data streamer) over image with corresponding boundinx box , and
    labelisation of objects, that outputs an iterable, that gives correspondance,
    between bbox (bounding boxes) , generated by the selective search algorithm,
    and the labelled bounding boxes from the csv
"""

from torch.utils.data import Dataset
import pandas as pd,numpy as np

from PIL import Image,ImageDraw
from pathlib import Path
dir_file = Path(__file__).parent

try:
    from ..utils.utils_bbox import bbox_mod
    from ...Data import data_manager
    from . import custom_transforms
except:
    from Code.utils.utils_bbox import bbox_mod
    from Data import data_manager
    from Code import custom_transforms



class DatasetRegionCrs(Dataset):
    def __init__(self,mode="train",joint_transform = None):
        """initisation of the dataset
            :mode : can be equal to train, val or test
        """

    ######## init options
        self.data_accessor = data_manager.DataAccessor(mode)
        self.groundTruth = self.read_detections_file()
        #
        # self.input_transform = input_transform
        # self.target_transform = target_transform
        self.joint_transform = joint_transform

        self.bbox_associator = custom_transforms.BboxAssociator()

    def read_detections_file(self):
        return self.data_accessor.read_csv_file()

    def get_pil_image_from_name(self,image_id):
        return self.data_accessor.get_pil_image_from_name(image_id)

    def __len__(self):
        return len(self.groundTruth.groupby("ImageID"))

    def __getitem__(self, idx):
        for i,(imageID, df) in enumerate(self.groundTruth.groupby("ImageID")):
            if i == idx:
                break


        pil_img = self.get_pil_image_from_name(imageID)

        col,row = pil_img.size

        # el = self.groundTruth.iloc[idx]
        bboxes_gd = []
        labels = []
        for row_df,el in df.iterrows():

            bbox = ((el.XMin*col,el.YMin*row),(el.XMax*col,el.YMax*row))
            label_name = data_manager.code_to_name_of_class[el.LabelName]

            bbox = bbox_mod.Bbox.from_extremes(*bbox)
            bboxes_gd.append(bbox)
            labels.append(label_name)


        # TODO : create a function of function (decorator),that
        # transforms a function that takes a limited number of arguments
        # for example pil_img and bbox, to a function, that takes as input,
        # all the arguments pil_img,bboxes_gd and labels
        # maybe using a dictionnary instead

        if self.joint_transform:
            pbboxes,bboxes_gd,ious = self.joint_transform(pil_img,bboxes_gd)

            return imageID,pbboxes,bboxes_gd,labels
        else:
            return pil_img,bboxes_gd,labels

    def draw_bbox_on_image(self,idx):
        img, bboxes,labels = self[idx]
        for bbox in bboxes:
            bbox.draw_on_image(img,False)
        img.show()

#TODO : to be tested

if __name__ == '__main__':

    bbox_associator_inst = custom_transforms.BboxAssociator()

    # import sys;sys.exit()
    mode = "validation"
    alg = DatasetRegionCrs(mode=mode,joint_transform=bbox_associator_inst)

    # imageID,pbboxes,bboxes_gd,labels = alg[1]

    # res = [el for el in alg]
    #mlm conseil
    res = []
    for i,el in enumerate(alg):
        # imageID, pbboxes, bboxes_gd, labels = el
        res.append(el)
        print(i)
        if i== 100: # at a first attempt, we use only a limited number of samples
            break
    from Code.utils import utils

    res11 = utils.convert_bboxes_to_bboxes_params(res)
    res1 = utils.transform_bboxes_gd_to_idxs(res11)
    aa = pd.DataFrame(res1, columns=["ID", "pbboxes", "bboxes_gd_idx", "labels", "idx_to_bbox"])

    from pathlib import Path
    re_path_csv = Path(f"../../Data/data/{mode}/labels/detections_filtered_with_region_proposals.csv")
    path_csv = dir_file.joinpath(re_path_csv)
    aa.to_csv(path_csv)

    aa_duplicate = utils.read_csv_and_eval(path_csv)
    # assert all(aa_duplicate == aa)
    res1_duplicate = aa_duplicate.values.tolist()
    res11_duplicate = utils.recover_bboxes_gd_from_idx(res1_duplicate)
    # assert res11_duplicate == res11

    res_duplicate = utils.convert_bboxes_params_to_bboxes(res11_duplicate)

    assert res_duplicate == res
    # res1&
    # res_duplicate
    # # bb = utils.read_csv_and_eval(path_csv)




